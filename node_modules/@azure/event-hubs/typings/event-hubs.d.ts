/// <reference types="node" />
import { AadTokenProvider } from '@azure/amqp-common';
import { AmqpError } from 'rhea-promise';
import { ApplicationTokenCredentials } from '@azure/ms-rest-nodeauth';
import { ConditionErrorNameMapper } from '@azure/amqp-common';
import { ConditionStatusMapper } from '@azure/amqp-common';
import { ConnectionConfig } from '@azure/amqp-common';
import { ConnectionContextBase } from '@azure/amqp-common';
import { DataTransformer } from '@azure/amqp-common';
import { DefaultDataTransformer } from '@azure/amqp-common';
import { delay } from '@azure/amqp-common';
import { Delivery } from 'rhea-promise';
import { DeliveryAnnotations } from 'rhea-promise';
import { DeviceTokenCredentials } from '@azure/ms-rest-nodeauth';
import { Dictionary } from 'rhea-promise';
import { ErrorNameConditionMapper } from '@azure/amqp-common';
import { EventHubConnectionConfig } from '@azure/amqp-common';
import { EventHubConnectionStringModel } from '@azure/amqp-common';
import { IotHubConnectionStringModel } from '@azure/amqp-common';
import { isIotHubConnectionString } from '@azure/amqp-common';
import { Message } from 'rhea-promise';
import { MessageAnnotations } from 'rhea-promise';
import { MessageHeader } from 'rhea-promise';
import { MessageProperties } from 'rhea-promise';
import { MessagingError } from '@azure/amqp-common';
import { MSITokenCredentials } from '@azure/ms-rest-nodeauth';
import { OnAmqpEvent } from 'rhea-promise';
import { parseConnectionString } from '@azure/amqp-common';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { SasTokenProvider } from '@azure/amqp-common';
import { Sender } from 'rhea-promise';
import { StorageConnectionStringModel } from '@azure/amqp-common';
import { Timeout } from '@azure/amqp-common';
import { TokenInfo } from '@azure/amqp-common';
import { TokenProvider } from '@azure/amqp-common';
import { TokenType } from '@azure/amqp-common';
import { UserTokenCredentials } from '@azure/ms-rest-nodeauth';
import { WebSocketImpl } from 'rhea-promise';

export declare const aadEventHubsAudience = "https://eventhubs.azure.net/";
export { AadTokenProvider }
export { AmqpError }

/**
 * Describes the checkoint information.
 * @interface CheckpointData
 */
declare interface CheckpointData {
    /**
     * @property {Date} enqueuedTimeUtc The enqueued time of the event.
     */
    enqueuedTimeUtc: Date;
    /**
     * @property {string} offset The offset of the event to be checked in.
     */
    offset: string;
    /**
     * @property {string} sequenceNumber The sequence number of the event to be checked in.
     */
    sequenceNumber: number;
}

/**
 * Describes the options that can be provided while creating the EventHub Client.
 * @interface ClientOptions
 */
export declare interface ClientOptions extends ClientOptionsBase {
    /**
     * @property {TokenProvider} [tokenProvider] - The token provider that provides the token for authentication.
     * Default value: SasTokenProvider.
     */
    tokenProvider?: TokenProvider;
}

/**
 * Describes the base client options.
 * @interface ClientOptionsBase
 */
export declare interface ClientOptionsBase {
    /**
     * @property {DataTransformer} [dataTransformer] The data transformer that will be used to encode
     * and decode the sent and received messages respectively. If not provided then we will use the
     * DefaultDataTransformer. The default transformer should handle majority of the cases. This
     * option needs to be used only for specialized scenarios.
     */
    dataTransformer?: DataTransformer;
    /**
     * @property {string} [userAgent] The user agent that needs to be appended to the built in
     * user agent string.
     */
    userAgent?: string;
    /**
     * @property The WebSocket constructor used to create an AMQP connection over a WebSocket.
     * This option should be provided in the below scenarios
     * - The TCP port 5671 which is what is used by the AMQP connection to Event Hubs is blocked in your environment.
     * - Your application needs to be run behind a proxy server
     * - Your application needs to run in the browser and you want to provide your own choice of Websocket implementation
     * instead of the built-in WebSocket in the browser.
     */
    webSocket?: WebSocketImpl;
    /**
     * @property {webSocketConstructorOptions} - Options to be passed to the WebSocket constructor
     */
    webSocketConstructorOptions?: any;
}
export { ConditionErrorNameMapper }
export { ConditionStatusMapper }
export { ConnectionConfig }

/**
 * @interface ConnectionContext
 * @ignore
 * Provides contextual information like the underlying amqp connection, cbs session, management session,
 * tokenProvider, senders, receivers, etc. about the EventHub client.
 */
declare interface ConnectionContext extends ConnectionContextBase {
    /**
     * @property {EventHubConnectionConfig} config The EventHub connection config that is created after
     * parsing the connection string.
     */
    readonly config: EventHubConnectionConfig;
    /**
     * @property {boolean} wasConnectionCloseCalled Indicates whether the close() method was
     * called on theconnection object.
     */
    wasConnectionCloseCalled: boolean;
    /**
     * @property {Dictionary<EventHubReceiver>} receivers A dictionary of the EventHub Receivers associated with this client.
     */
    receivers: Dictionary<EventHubReceiver>;
    /**
     * @property {Dictionary<EventHubSender>} senders A dictionary of the EventHub Senders associated with this client.
     */
    senders: Dictionary<EventHubSender>;
    /**
     * @property {ManagementClient} managementSession A reference to the management session ($management endpoint) on
     * the underlying amqp connection for the EventHub Client.
     */
    managementSession?: ManagementClient;
}

declare namespace ConnectionContext {
    function getUserAgent(options: ConnectionContextOptions): string;
    function create(config: EventHubConnectionConfig, options?: ConnectionContextOptions): ConnectionContext;
}

declare interface ConnectionContextOptions extends ClientOptions {
    managementSessionAddress?: string;
    managementSessionAudience?: string;
}

declare interface CreateReceiverOptions {
    onMessage: OnAmqpEvent;
    onError: OnAmqpEvent;
    onClose: OnAmqpEvent;
    onSessionError: OnAmqpEvent;
    onSessionClose: OnAmqpEvent;
    newName?: boolean;
    eventPosition?: EventPosition;
}
export { DataTransformer }
export { DefaultDataTransformer }
export { delay }
export { Delivery }
export { Dictionary }
export { ErrorNameConditionMapper }

/**
 * Describes the structure of an event to be sent or received from the EventHub.
 * @interface EventData
 */
export declare interface EventData {
    /**
     * @property {MessageHeader} [header] - The message headers.
     */
    header?: MessageHeader;
    /**
     * @property {any} body - The message body that needs to be sent or is received.
     */
    body: any;
    /**
     * @property {Date} [enqueuedTimeUtc] The enqueued time of the event.
     */
    enqueuedTimeUtc?: Date;
    /**
     * @property {string | null} [partitionKey] If specified EventHub will hash this to a partitionId.
     * It guarantees that messages end up in a specific partition on the event hub.
     */
    partitionKey?: string | null;
    /**
     * @property {string} [offset] The offset of the event.
     */
    offset?: string;
    /**
     * @property {number} [sequenceNumber] The sequence number of the event.
     */
    sequenceNumber?: number;
    /**
     * @property {AmqpMessageAnnotations} [annotations] The amqp message attributes.
     */
    annotations?: EventHubMessageAnnotations;
    /**
     * @property {AmqpMessageProperties} [properties] The predefined AMQP properties like message_id, correlation_id, reply_to, etc.
     */
    properties?: MessageProperties;
    /**
     * @property {Dictionary<any>} [applicationProperties] The application specific properties.
     */
    applicationProperties?: Dictionary<any>;
    /**
     * @property {number} [lastSequenceNumber] The last sequence number of the event within the partition stream of the Event Hub.
     */
    lastSequenceNumber?: number;
    /**
     * @property {string} [lastEnqueuedOffset] The offset of the last enqueued event.
     */
    lastEnqueuedOffset?: string;
    /**
     * @property {Date} [lastEnqueuedTime] The enqueued UTC time of the last event.
     */
    lastEnqueuedTime?: Date;
    /**
     * @property {Date} [retrievalTime] The time when the runtime info was retrieved
     */
    retrievalTime?: Date;
    /**
     * @property {AmqpMessage} _raw_amqp_mesage The underlying raw amqp message.
     */
    _raw_amqp_mesage?: Message;
}

/**
 * Describes the methods on the EventData interface.
 * @module EventData
 */
export declare namespace EventData {
    /**
     * Converts the AMQP message to an EventData.
     * @param {AmqpMessage} msg The AMQP message that needs to be converted to EventData.
     */
    export function fromAmqpMessage(msg: Message): EventData;
    /**
     * Converts an EventData object to an AMQP message.
     * @param {EventData} data The EventData object that needs to be converted to an AMQP message.
     */
    export function toAmqpMessage(data: EventData): Message;
}

/**
 * @class EventHubClient
 * Describes the EventHub client.
 */
export declare class EventHubClient {
    /**
     * @property {string} [connectionId] The amqp connection id that uniquely identifies the connection within a process.
     */
    connectionId?: string;
    /**
     * @property {string} eventhubName The name of the Eventhub.
     * @readonly
     */
    readonly eventhubName: string;
    /**
     * @property {ConnectionContext} _context Describes the amqp connection context for the eventhub client.
     * @private
     */
    private _context;
    /**
     * Instantiates a client pointing to the Event Hub given by this configuration.
     *
     * @constructor
     * @param {EventHubConnectionConfig} config - The connection configuration to create the EventHub Client.
     * @param {ClientOptions} options - The optional parameters that can be provided to the EventHub
     * Client constructor.
     */
    constructor(config: EventHubConnectionConfig, options?: ClientOptions);
    /**
     * Closes the AMQP connection to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns {Promise<void>} Promise<void>
     */
    close(): Promise<void>;
    /**
     * Sends the given message to the EventHub.
     *
     * @param {any} data                    Message to send.  Will be sent as UTF8-encoded JSON string.
     * @param {string|number} [partitionId] Partition ID to which the event data needs to be sent. This should only be specified
     * if you intend to send the event to a specific partition. When not specified EventHub will store the messages in a round-robin
     * fashion amongst the different partitions in the EventHub.
     *
     * @returns {Promise<Delivery>} Promise<Delivery>
     */
    send(data: EventData, partitionId?: string | number): Promise<Delivery>;
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations", "application_properties" and "properties"
     * of the first message will be set as that of the envelope (batch message).
     *
     * @param {Array<EventData>} datas  An array of EventData objects to be sent in a Batch message.
     * @param {string|number} [partitionId] Partition ID to which the event data needs to be sent. This should only be specified
     * if you intend to send the event to a specific partition. When not specified EventHub will store the messages in a round-robin
     * fashion amongst the different partitions in the EventHub.
     *
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    sendBatch(datas: EventData[], partitionId?: string | number): Promise<Delivery>;
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session. Messages will be passed to
     * the provided onMessage handler and error will be passed to the provided onError handler.
     *
     * @param {string|number} partitionId                        Partition ID from which to receive.
     * @param {OnMessage} onMessage                              The message handler to receive event data objects.
     * @param {OnError} onError                                  The error handler to receive an error that occurs
     * while receiving messages.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to receive messages.
     *
     * @returns {ReceiveHandler} ReceiveHandler - An object that provides a mechanism to stop receiving more messages.
     */
    receive(partitionId: string | number, onMessage: OnMessage, onError: OnError, options?: ReceiveOptions): ReceiveHandler;
    /**
     * Receives a batch of EventData objects from an EventHub partition for a given count and a given max wait time in seconds, whichever
     * happens first. This method can be used directly after creating the receiver object and **MUST NOT** be used along with the `start()` method.
     *
     * @param {string|number} partitionId                        Partition ID from which to receive.
     * @param {number} maxMessageCount                           The maximum message count. Must be a value greater than 0.
     * @param {number} [maxWaitTimeInSeconds]                    The maximum wait time in seconds for which the Receiver should wait
     * to receiver the said amount of messages. If not provided, it defaults to 60 seconds.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to receive messages.
     *
     * @returns {Promise<Array<EventData>>} Promise<Array<EventData>>.
     */
    receiveBatch(partitionId: string | number, maxMessageCount: number, maxWaitTimeInSeconds?: number, options?: ReceiveOptions): Promise<EventData[]>;
    /**
     * Provides the eventhub runtime information.
     * @returns {Promise<EventHubRuntimeInformation>} A promise that resolves with EventHubRuntimeInformation.
     */
    getHubRuntimeInformation(): Promise<EventHubRuntimeInformation>;
    /**
     * Provides an array of partitionIds.
     * @returns {Promise<Array<string>>} A promise that resolves with an Array of strings.
     */
    getPartitionIds(): Promise<Array<string>>;
    /**
     * Provides information about the specified partition.
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     * @returns {Promise<EventHubPartitionRuntimeInformation>} A promise that resoloves with EventHubPartitionRuntimeInformation.
     */
    getPartitionInformation(partitionId: string | number): Promise<EventHubPartitionRuntimeInformation>;
    /**
     * Creates an EventHub Client from connection string.
     * @param {string} connectionString - Connection string of the form 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {string} [path] - EventHub path of the form 'my-event-hub-name'
     * @param {ClientOptions} [options] Options that can be provided during client creation.
     * @returns {EventHubClient} - An instance of the eventhub client.
     */
    static createFromConnectionString(connectionString: string, path?: string, options?: ClientOptions): EventHubClient;
    /**
     * Creates an EventHub Client from connection string.
     * @param {string} iothubConnectionString - Connection string of the form 'HostName=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {ClientOptions} [options] Options that can be provided during client creation.
     * @returns {Promise<EventHubClient>} - Promise<EventHubClient>.
     */
    static createFromIotHubConnectionString(iothubConnectionString: string, options?: ClientOptions): Promise<EventHubClient>;
    /**
     * Creates an EventHub Client from a generic token provider.
     * @param {string} host - Fully qualified domain name for Event Hubs. Most likely,
     * <yournamespace>.servicebus.windows.net
     * @param {string} entityPath - EventHub path of the form 'my-event-hub-name'
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {ClientOptionsBase} options - The options that can be provided during client creation.
     * @returns {EventHubClient} An instance of the Eventhub client.
     */
    static createFromTokenProvider(host: string, entityPath: string, tokenProvider: TokenProvider, options?: ClientOptionsBase): EventHubClient;
    /**
     * Creates an EventHub Client from AADTokenCredentials.
     * @param {string} host - Fully qualified domain name for Event Hubs. Most likely,
     * <yournamespace>.servicebus.windows.net
     * @param {string} entityPath - EventHub path of the form 'my-event-hub-name'
     * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the following:
     * ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials.
     * @param {ClientOptionsBase} options - The options that can be provided during client creation.
     * @returns {EventHubClient} An instance of the Eventhub client.
     */
    static createFromAadTokenCredentials(host: string, entityPath: string, credentials: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials, options?: ClientOptionsBase): EventHubClient;
}
export { EventHubConnectionConfig }
export { EventHubConnectionStringModel }

/**
 * Describes the delivery annotations.
 * @interface EventHubDeliveryAnnotations
 */
export declare interface EventHubDeliveryAnnotations extends DeliveryAnnotations {
    /**
     * @property {string} [last_enqueued_offset] The offset of the last event.
     */
    last_enqueued_offset?: string;
    /**
     * @property {number} [last_enqueued_sequence_number] The sequence number of the last event.
     */
    last_enqueued_sequence_number?: number;
    /**
     * @property {number} [last_enqueued_time_utc] The enqueued time of the last event.
     */
    last_enqueued_time_utc?: number;
    /**
     * @property {number} [runtime_info_retrieval_time_utc] The retrieval time of the last event.
     */
    runtime_info_retrieval_time_utc?: number;
    /**
     * @property {string} Any unknown delivery annotations.
     */
    [x: string]: any;
}

/**
 * Map containing message attributes that will be held in the message header.
 * @interface EventHubMessageAnnotations
 */
export declare interface EventHubMessageAnnotations extends MessageAnnotations {
    /**
     * @property {string | null} [x-opt-partition-key] Annotation for the partition key set for the event.
     */
    "x-opt-partition-key"?: string | null;
    /**
     * @property {number} [x-opt-sequence-number] Annontation for the sequence number of the event.
     */
    "x-opt-sequence-number"?: number;
    /**
     * @property {number} [x-opt-enqueued-time] Annotation for the enqueued time of the event.
     */
    "x-opt-enqueued-time"?: number;
    /**
     * @property {string} [x-opt-offset] Annotation for the offset of the event.
     */
    "x-opt-offset"?: string;
    /**
     * @property {any} Any other annotation that can be added to the message.
     */
    [x: string]: any;
}

/**
 * Describes the runtime information of an EventHub Partition.
 * @interface EventHubPartitionRuntimeInformation
 */
export declare interface EventHubPartitionRuntimeInformation {
    /**
     * @property {string} hubPath - The name of the eventhub.
     */
    hubPath: string;
    /**
     * @property {string} partitionId - Identifier of the partition within the eventhub.
     */
    partitionId: string;
    /**
     * @property {number} beginningSequenceNumber - The starting sequence number of the partition's message log.
     */
    beginningSequenceNumber: number;
    /**
     * @property {number} lastSequenceNumber - The last sequence number of the partition's message log.
     */
    lastSequenceNumber: number;
    /**
     * @property {string} lastEnqueuedOffset - The offset of the last enqueued message in the partition's message log.
     */
    lastEnqueuedOffset: string;
    /**
     * @property {Date} lastEnqueuedTimeUtc - The time of the last enqueued message in the partition's message log in UTC.
     */
    lastEnqueuedTimeUtc: Date;
    /**
     * @property {string} type - The type of entity.
     */
    type: "com.microsoft:partition";
}

/**
 * Describes the EventHubReceiver that will receive event data from EventHub.
 * @class EventHubReceiver
 * @ignore
 */
declare class EventHubReceiver extends LinkEntity {
    /**
     * @property {string} consumerGroup The EventHub consumer group from which the receiver will
     * receive messages. (Default: "default").
     */
    consumerGroup: string;
    /**
     * @property {ReceiverRuntimeInfo} runtimeInfo The receiver runtime info.
     */
    runtimeInfo: ReceiverRuntimeInfo;
    /**
     * @property {number} [epoch] The Receiver epoch.
     */
    epoch?: number;
    /**
     * @property {string} [identifier] The Receiver identifier
     */
    identifier?: string;
    /**
     * @property {ReceiveOptions} [options] Optional properties that can be set while creating
     * the EventHubReceiver.
     */
    options: ReceiveOptions;
    /**
     * @property {number} [prefetchCount] The number of messages that the receiver can fetch/receive
     * initially. Defaults to 1000.
     */
    prefetchCount?: number;
    /**
     * @property {boolean} receiverRuntimeMetricEnabled Indicates whether receiver runtime metric
     * is enabled. Default: false.
     */
    receiverRuntimeMetricEnabled: boolean;
    /**
     * @property {Receiver} [_receiver] The AMQP receiver link.
     * @protected
     */
    protected _receiver?: Receiver;
    /**
     * @property {OnMessage} _onMessage The message handler provided by the user that will be wrapped
     * inside _onAmqpMessage.
     * @protected
     */
    protected _onMessage?: OnMessage;
    /**
     * @property {OnError} _onError The error handler provided by the user that will be wrapped
     * inside _onAmqpError.
     * @protected
     */
    protected _onError?: OnError;
    /**
     * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the
     * underlying rhea receiver for the "message" event.
     * @protected
     */
    protected _onAmqpMessage: OnAmqpEvent;
    /**
     * @property {OnAmqpEvent} _onAmqpError The message handler that will be set as the handler on the
     * underlying rhea receiver for the "receiver_error" event.
     * @protected
     */
    protected _onAmqpError: OnAmqpEvent;
    /**
     * @property {OnAmqpEvent} _onAmqpClose The message handler that will be set as the handler on the
     * underlying rhea receiver for the "receiver_close" event.
     * @protected
     */
    protected _onAmqpClose: OnAmqpEvent;
    /**
     * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on
     * the underlying rhea receiver's session for the "session_error" event.
     * @protected
     */
    protected _onSessionError: OnAmqpEvent;
    /**
     * @property {OnAmqpEvent} _onSessionClose The message handler that will be set as the handler on
     * the underlying rhea receiver's session for the "session_close" event.
     * @protected
     */
    protected _onSessionClose: OnAmqpEvent;
    /**
     * @property {CheckpointData} _checkpoint Describes metadata about the last message received.
     * This is used as the offset to receive messages from incase of recovery.
     */
    protected _checkpoint: CheckpointData;
    /**
     * Instantiate a new receiver from the AMQP `Receiver`. Used by `EventHubClient`.
     * @ignore
     * @constructor
     * @param {EventHubClient} client                            The EventHub client.
     * @param {string} partitionId                               Partition ID from which to receive.
     * @param {ReceiveOptions} [options]                         Receiver options.
     */
    constructor(context: ConnectionContext, partitionId: string | number, options?: ReceiveOptions);
    /**
     * Will reconnect the receiver link if necessary.
     * @ignore
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    detached(receiverError?: AmqpError | Error): Promise<void>;
    /**
     * Closes the underlying AMQP receiver.
     * @ignore
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @ignore
     * @return {boolean} boolean
     */
    isOpen(): boolean;
    protected _deleteFromCache(): void;
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @ignore
     * @returns {Promise<void>}
     */
    protected _init(options?: ReceiverOptions): Promise<void>;
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     * @ignore
     */
    protected _createReceiverOptions(options: CreateReceiverOptions): ReceiverOptions;
}

/**
 * Describes the runtime information of an EventHub.
 * @interface EventHubRuntimeInformation
 */
export declare interface EventHubRuntimeInformation {
    /**
     * @property {string} path - The name of the event hub.
     */
    path: string;
    /**
     * @property {Date} createdAt - The date and time the hub was created in UTC.
     */
    createdAt: Date;
    /**
     * @property {number} partitionCount - The number of partitions in the event hub.
     */
    partitionCount: number;
    /**
     * @property {string[]} partitionIds - The slice of string partition identifiers.
     */
    partitionIds: string[];
    /**
     * @property {string} type - The type of entity.
     */
    type: "com.microsoft:eventhub";
}

/**
 * Describes the EventHubSender that will send event data to EventHub.
 * @class EventHubSender
 * @ignore
 */
declare class EventHubSender extends LinkEntity {
    /**
     * @property {string} senderLock The unqiue lock name per connection that is used to acquire the
     * lock for establishing a sender link by an entity on that connection.
     * @readonly
     */
    readonly senderLock: string;
    /**
     * @property {OnAmqpEvent} _onAmqpError The handler function to handle errors that happen on the
     * underlying sender.
     * @readonly
     */
    private readonly _onAmqpError;
    /**
     * @property {OnAmqpEvent} _onAmqpClose The handler function to handle "sender_close" event
     * that happens on the underlying sender.
     * @readonly
     */
    private readonly _onAmqpClose;
    /**
     * @property {OnAmqpEvent} _onSessionError The message handler that will be set as the handler on
     * the underlying rhea sender's session for the "session_error" event.
     * @private
     */
    private _onSessionError;
    /**
     * @property {OnAmqpEvent} _onSessionClose The message handler that will be set as the handler on
     * the underlying rhea sender's session for the "session_close" event.
     * @private
     */
    private _onSessionClose;
    /**
     * @property {Sender} [_sender] The AMQP sender link.
     * @private
     */
    private _sender?;
    /**
     * Creates a new EventHubSender instance.
     * @ignore
     * @constructor
     * @param {ConnectionContext} context The connection context.
     * @param {string|number} [partitionId] The EventHub partition id to which the sender
     * wants to send the event data.
     */
    constructor(context: ConnectionContext, partitionId?: string | number, name?: string);
    /**
     * Will reconnect the sender link if necessary.
     * @ignore
     * @param {AmqpError | Error} [senderError] The sender error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    detached(senderError?: AmqpError | Error): Promise<void>;
    /**
     * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
     * @ignore
     * @return {Promise<void>} Promise<void>
     */
    close(): Promise<void>;
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @ignore
     * @return {boolean} boolean
     */
    isOpen(): boolean;
    /**
     * Sends the given message, with the given options on this link
     * @ignore
     * @param {any} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<Delivery>} Promise<Delivery>
     */
    send(data: EventData): Promise<Delivery>;
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @ignore
     * @param {Array<EventData>} datas  An array of EventData objects to be sent in a Batch message.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    sendBatch(datas: EventData[]): Promise<Delivery>;
    private _deleteFromCache;
    private _createSenderOptions;
    /**
     * Tries to send the message to EventHub if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     * @ignore
     * @param message The message to be sent to EventHub.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    private _trySend;
    /**
     * Initializes the sender session on the connection.
     * @ignore
     * @returns {Promise<void>}
     */
    private _init;
    /**
     * Creates a new sender to the given event hub, and optionally to a given partition if it is
     * not present in the context or returns the one present in the context.
     * @ignore
     * @static
     * @param {(string|number)} [partitionId] Partition ID to which it will send event data.
     * @returns {Promise<EventHubSender>}
     */
    static create(context: ConnectionContext, partitionId?: string | number): EventHubSender;
}

/**
 * Represents options can be set during the creation of a event hub receiver.
 * Defines a position of an @link~EventData in the event hub partition.
 * @class EventPosition
 */
export declare class EventPosition {
    /**
     * @property {string} startOfStream The offset from which events would be received: `"-1"`.
     * @static
     * @readonly
     */
    static readonly startOfStream: string;
    /**
     * @property {string} endOfStream The offset from which events would be received: `"@latest"`.
     * @static
     * @readonly
     */
    static readonly endOfStream: string;
    /**
     * @property {string} [offset] The offset of the event at the position. It can be undefined
     * if the position is just created from a sequence number or an enqueued time.
     */
    offset?: string;
    /**
     * @property {boolean} isInclusive Indicates if the current event at the specified offset is
     * included or not. It is only applicable if offset is set. Default value: false.
     */
    isInclusive: boolean;
    /**
     * @property {Date|number} [enqueuedTime] The enqueued time of the event at the position. It can be undefined
     * if the position is just created from a sequence number or an offset.
     */
    enqueuedTime?: Date | number;
    /**
     * @property {number} [sequenceNumber] The sequence number of the event at the position. It can be undefined
     * if the position is just created from an enqueued time or an offset.
     */
    sequenceNumber?: number;
    /**
     * @property {string} [customFilter] The custom filter expression that needs to be set on the receiver.
     */
    customFilter?: string;
    constructor(options?: EventPositionOptions);
    /**
     * Gets the expression (filter clause) that needs to be set on the source.
     * @return {string} filterExpression
     */
    getExpression(): string;
    /**
     * Creates a position at the given offset.
     * @param {string} offset The offset of the data relative to the Event Hub partition stream.
     * The offset is a marker or identifier for an event within the Event Hubs stream.
     * The identifier is unique within a partition of the Event Hubs stream.
     * @param {boolean} isInclusive If true, the specified event is included;
     * otherwise the next event is returned. Default: false.
     * @return {EventPosition} EventPosition
     */
    static fromOffset(offset: string, isInclusive?: boolean): EventPosition;
    /**
     * Creates a position at the given sequence number.
     * @param {number} sequenceNumber The logical sequence number of the event within the partition stream of the Event Hub.
     * @param {boolean} isInclusive If true, the specified event is included;
     * otherwise the next event is returned. Default false.
     * @return {EventPosition} EventPosition
     */
    static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition;
    /**
     * Creates a position at the given enqueued time.
     * @param {Date | number} enqueuedTime The enqueue time. This value represents the actual time of enqueuing the message.
     * @param {boolean} isInclusive If true, the specified event is included; otherwise the next event is returned.
     * @return {EventPosition} EventPosition
     */
    static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition;
    /**
     * Creates a position based on the given custom filter.
     * @param {string} customFilter The cutom filter expression that needs to be applied on the receiver. This should be used
     * only when one of the other methods `fromOffset()`, `fromSequenceNumber()`, `fromEnqueuedTime()` is not applicable for
     * your scenario.
     */
    static withCustomFilter(customFilter: string): EventPosition;
    /**
     * Returns the position for the start of a stream. Provide this position in receiver creation to
     * start receiving from the first available event in the partition.
     * @return {EventPosition} EventPosition
     */
    static fromStart(): EventPosition;
    /**
     * Returns the position for the end of a stream. Provide this position in receiver creation to
     * start receiving from the next available event in the partition after the receiver is created.
     * @return {EventPosition} EventPosition
     */
    static fromEnd(): EventPosition;
}

/**
 * Describes the options that can be set while creating an EventPosition.
 * @ignore
 * @interface EventPositionOptions
 */
declare interface EventPositionOptions {
    /**
     * @property {string} [offset] The offset of the event at the position. It can be undefined
     * if the position is just created from a sequence number or an enqueued time.
     */
    offset?: string;
    /**
     * @property {boolean} isInclusive Indicates if the current event at the specified offset is
     * included or not. It is only applicable if offset is set. Default value: false.
     */
    isInclusive?: boolean;
    /**
     * @property {Date|number} [enqueuedTime] The enqueued time of the event at the position. It can be undefined
     * if the position is just created from a sequence number or an offset.
     */
    enqueuedTime?: Date | number;
    /**
     * @property {number} [sequenceNumber] The sequence number of the event at the position. It can be undefined
     * if the position is just created from an enqueued time or an offset.
     */
    sequenceNumber?: number;
    /**
     * @property {string} [customFilter] The custom filter expression that needs to be set on the receiver.
     */
    customFilter?: string;
}
export { IotHubConnectionStringModel }
export { isIotHubConnectionString }

/**
 * Describes the base class for entities like EventHub Sender, Receiver and Management link.
 * @ignore
 * @class LinkEntity
 */
declare class LinkEntity {
    /**
     * @property {string} [name] The unique name for the entity (mostly a guid).
     */
    name: string;
    /**
     * @property {string} address The link entity address in one of the following forms:
     *
     * **Sender**
     * - `"<hubName>"`
     * - `"<hubName>/Partitions/<partitionId>"`.
     *
     * **Receiver**
     * - `"<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     * **ManagementClient**
     * -`"$management"`.
     */
    address: string;
    /**
     * @property {string} audience The link entity token audience in one of the following forms:
     *
     * **Sender**
     * - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
     * - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
     *
     * **Receiver**
     * - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
     *
     * **ManagementClient**
     * - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
     */
    audience: string;
    /**
     * @property {string | number} [partitionId] The partitionId associated with the link entity.
     */
    partitionId?: string | number;
    /**
     * @property {boolean} isConnecting Indicates whether the link is in the process of connecting
     * (establishing) itself. Default value: `false`.
     */
    isConnecting: boolean;
    /**
     * @property {ConnectionContext} _context Provides relevant information about the amqp connection,
     * cbs and $management sessions, token provider, sender and receivers.
     * @protected
     */
    protected _context: ConnectionContext;
    /**
     * @property {NodeJS.Timer} _tokenRenewalTimer The token renewal timer that keeps track of when
     * the Link Entity is due for token renewal.
     * @protected
     */
    protected _tokenRenewalTimer?: NodeJS.Timer;
    /**
     * Creates a new LinkEntity instance.
     * @ignore
     * @constructor
     * @param {ConnectionContext} context The connection context.
     * @param {LinkEntityOptions} [options] Options that can be provided while creating the LinkEntity.
     */
    constructor(context: ConnectionContext, options?: LinkEntityOptions);
    /**
     * Negotiates cbs claim for the LinkEntity.
     * @ignore
     * @protected
     * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
     * @return {Promise<void>} Promise<void>
     */
    protected _negotiateClaim(setTokenRenewal?: boolean): Promise<void>;
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @ignore
     * @protected
     * @returns {void}
     */
    protected _ensureTokenRenewal(): Promise<void>;
    /**
     * Closes the Sender|Receiver link and it's underlying session and also removes it from the
     * internal map.
     * @ignore
     * @param {Sender | Receiver} [link] The Sender or Receiver link that needs to be closed and
     * removed.
     */
    protected _closeLink(link?: Sender | Receiver): Promise<void>;
    /**
     * Provides the current type of the LinkEntity.
     * @return {string} The entity type.
     */
    private readonly _type;
}

declare interface LinkEntityOptions {
    /**
     * @property {string} [name] The unique name for the entity. If not provided then a guid will be
     * assigned.
     */
    name?: string;
    /**
     * @property {string | number} [partitionId] The partitionId associated with the link entity.
     */
    partitionId?: string | number;
    /**
     * @property {string} address The link entity address in one of the following forms:
     */
    address?: string;
    /**
     * @property {string} audience The link entity token audience in one of the following forms:
     */
    audience?: string;
}

/**
 * @class ManagementClient
 * @ignore
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
declare class ManagementClient extends LinkEntity {
    readonly managementLock: string;
    /**
     * @property {string} entityPath - The name/path of the entity (hub name) for which the management
     * request needs to be made.
     */
    entityPath: string;
    /**
     * @property {string} replyTo The reply to Guid for the management client.
     */
    replyTo: string;
    /**
     * $management sender, receiver on the same session.
     * @private
     */
    private _mgmtReqResLink?;
    /**
     * Instantiates the management client.
     * @constructor
     * @ignore
     * @param {BaseConnectionContext} context The connection context.
     * @param {string} [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context: ConnectionContext, options?: ManagementClientOptions);
    /**
     * Provides the eventhub runtime information.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    getHubRuntimeInformation(): Promise<EventHubRuntimeInformation>;
    /**
     * Provides an array of partitionIds.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<Array<string>>}
     */
    getPartitionIds(): Promise<Array<string>>;
    /**
     * Provides information about the specified partition.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     */
    getPartitionInformation(partitionId: string | number): Promise<EventHubPartitionRuntimeInformation>;
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @return {Promise<void>}
     */
    close(): Promise<void>;
    private _init;
    /**
     * @private
     * Helper method to make the management request
     * @param {Connection} connection - The established amqp connection
     * @param {string} type - The type of entity requested for. Valid values are "eventhub", "partition"
     * @param {string | number} [partitionId] - The partitionId. Required only when type is "partition".
     */
    private _makeManagementRequest;
    private _isMgmtRequestResponseLinkOpen;
}

declare interface ManagementClientOptions {
    address?: string;
    audience?: string;
}
export { Message }
export { MessageHeader }
export { MessageProperties }
export { MessagingError }

/**
 * Describes the error handler signature.
 */
export declare type OnError = (error: MessagingError | Error) => void;

/**
 * Describes the message handler signature.
 */
export declare type OnMessage = (eventData: EventData) => void;
export { parseConnectionString }

/**
 * Describes the receive handler object that is returned from the receive() method with handlers is
 * called. The ReceiveHandler is used to stop receiving more messages.
 * @class ReceiveHandler
 */
export declare class ReceiveHandler {
    /**
     * @property {string} name The Receiver handler name.
     * @readonly
     */
    readonly name: string;
    /**
     * @property {EventHubReceiver} _receiver  The underlying EventHubReceiver.
     * @private
     */
    private _receiver;
    /**
     * Creates an instance of the ReceiveHandler.
     * @constructor
     * @param {EventHubReceiver} receiver The underlying EventHubReceiver.
     */
    constructor(receiver: EventHubReceiver);
    /**
     * @property {string | number} [partitionId] The partitionId from which the handler is receiving
     * events from.
     * @readonly
     */
    readonly partitionId: string | number | undefined;
    /**
     * @property {string} [consumerGroup] The consumer group from which the handler is receiving
     * events from.
     * @readonly
     */
    readonly consumerGroup: string | undefined;
    /**
     * @property {string} [address] The address of the underlying receiver.
     * @readonly
     */
    readonly address: string | undefined;
    /**
     * @property {number} [epoch] The epoch value of the underlying receiver, if present.
     * @readonly
     */
    readonly epoch: number | undefined;
    /**
     * @property {string} [identifier] The identifier of the underlying receiver, if present.
     * @readonly
     */
    readonly identifier: string | undefined;
    /**
     * @property {ReceiverRuntimeInfo} [runtimeInfo] The receiver runtime info. This property will only
     * be enabled when `enableReceiverRuntimeMetric` option is set to true in the
     * `client.receive()` method.
     * @readonly
     */
    readonly runtimeInfo: ReceiverRuntimeInfo | undefined;
    /**
     * @property {boolean} isReceiverOpen Indicates whether the receiver is connected/open.
     * `true` - is open; `false` otherwise.
     * @readonly
     */
    readonly isReceiverOpen: boolean;
    /**
     * Stops the underlying EventHubReceiver from receiving more messages.
     * @return {Promise<void>} Promise<void>
     */
    stop(): Promise<void>;
}

/**
 * Describes the options that one can set while receiving messages.
 * @interface ReceiveOptions
 */
export declare interface ReceiveOptions {
    /**
     * @property {string} [name] The name of the receiver. If not provided then we will set a GUID by default.
     */
    name?: string;
    /**
     * @property {object} [eventPosition] The starting event position at which to start receiving messages.
     * This is used to filter messages for the EventHub Receiver.
     */
    eventPosition?: EventPosition;
    /**
     * @property {string} [consumerGroup] The consumer group to which the receiver wants to connect to.
     * If not provided then it will be connected to "$default" consumer group.
     */
    consumerGroup?: string;
    /**
     * @property {number} [prefetchCount] The upper limit of events this receiver will actively receive
     * regardless of whether a receive operation is pending. Defaults to 1000.
     */
    prefetchCount?: number;
    /**
     * @property {number} [epoch] The epoch value that this receiver is currently using for partition ownership.
     */
    epoch?: number;
    /**
     * @property {string} [identifier] The receiver identifier that uniqely identifies the receiver.
     */
    identifier?: string;
    /**
     * @property {boolean} [enableReceiverRuntimeMetric] A value indicating whether the runtime metric of a receiver is enabled.
     */
    enableReceiverRuntimeMetric?: boolean;
}

/**
 * Represents the approximate receiver runtime information for a logical partition of an Event Hub.
 * @interface ReceiverRuntimeInfo
 */
export declare interface ReceiverRuntimeInfo {
    /**
     * @property {string} partitionId The parition identifier.
     */
    partitionId: string;
    /**
     * @property {number} lastSequenceNumber The logical sequence number of the event.
     */
    lastSequenceNumber?: number;
    /**
     * @property {Date} lastEnqueuedTimeUtc The enqueued time of the last event.
     */
    lastEnqueuedTimeUtc?: Date;
    /**
     * @property {string} lastEnqueuedOffset The offset of the last enqueued event.
     */
    lastEnqueuedOffset?: string;
    /**
     * @property {Date} retrievalTime The enqueued time of the last event.
     */
    retrievalTime?: Date;
}
export { SasTokenProvider }
export { StorageConnectionStringModel }
export { Timeout }
export { TokenInfo }
export { TokenProvider }
export { TokenType }
export { WebSocketImpl }

export { }
